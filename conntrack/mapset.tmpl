{{$type := index $ 0}}
{{$package := index $ 1}}
{{$key := index $ 2 }}
{{$set := index $ 3 }}
{{$setKey := index $ 4 }}

package {{$package }}

type {{$type}} struct{
    m map[{{$key}}]{{$set}}
}

func New{{$type}}() {{$type}} {
    return {{$type}}{
        m: make(map[{{$key}}]{{$set}}),
    }
}

func (me {{$type}}) Contains(k {{$key}}) bool {
    _, ok := me.m[k]
    return ok
}

func (me {{$type}}) Get(k {{$key}}) {{$set}} {
	return me.m[k]
}

func (me {{$type}}) DeleteFromSet(k {{$key}}, sk {{$setKey}}) bool {
    s, ok := me.m[k]
    if !ok {
        return true
    }
    s = s.Delete(sk)
    if s.Len() == 0 {
        delete(me.m, k)
        return true
    }
    me.m[k] = s
    return false
}

func (me {{$type}}) AddToSet(k {{$key}}, sk {{$setKey}}) {
    s, ok := me.m[k]
    if ok {
        s = s.Add(sk)
    } else {
        s = NewentryHandleSet(sk)
    }
    me.m[k] = s
}

func (me {{$type}}) Len() int {
	return len(me.m)
}

func (me {{$type}}) Range(f func ({{$key}}, {{$set}}) bool) {
	for k, s := range me.m {
		if !f(k, s) {
			break
		}
	}
}